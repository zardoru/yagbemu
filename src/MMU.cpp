#include "MMU.h"

// the mmu in general does not assume low-endianness from the target machine.
namespace GBEmu {

	unsigned char GBbootstrap[256] = {
		0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB,
		0x21, 0x26, 0xFF, 0x0E, 0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3,
		0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0, 0x47, 0x11, 0x04, 0x01,
		0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
		0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22,
		0x23, 0x05, 0x20, 0xF9, 0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99,
		0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20, 0xF9, 0x2E, 0x0F, 0x18,
		0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
		0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20,
		0xF7, 0x1D, 0x20, 0xF2, 0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62,
		0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06, 0x7B, 0xE2, 0x0C, 0x3E,
		0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
		0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17,
		0xC1, 0xCB, 0x11, 0x17, 0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
		0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83,
		0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
		0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63,
		0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
		0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C, 0x21, 0x04, 0x01, 0x11,
		0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
		0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE,
		0x3E, 0x01, 0xE0, 0x50
	};


	MMU::MMU()
	{
		rom = nullptr;

		inbios = true;
		MBC1 = false;
		MBC2 = false;
		rambankEnabled = 0;

		// zero the memory, then load the bootstrap program in 0x00.
		memset(ram.memory, 0, 0x10000);
		swappedrambank = 0;
		swappedrombank = 1;
	}

	void MMU::setMBC1(bool nv)
	{
		MBC1 = nv;
	}

	void MMU::doRomBanking(byte val)
	{
		// 011 111 = 037 or 1F 0001 1111
		word mask = wbits("00011111");
		swappedrombank &= ~mask;
		if (!val)
			swappedrombank |= 1;
		else
		{
			// lower 5 bits of the rom bank are set here 
			swappedrombank |= val & mask;
		}
	}

	// the byte versions handle the details of banking and whatever.

	void MMU::doMBCstuff(word addr, byte val)
	{
		if (MBC1)
		{
			if (addr >= 0x2000 && addr < 0x4000) // okay then, we're doing banking.
			{ // ROM banking
				doRomBanking(val);
				return;
			}
			else if (addr >= 0x6000 && addr < 8000)
			{ // ROM/RAM mode select
				if (val % 1)
					memoryModel = rambanking;
				else
					memoryModel = rombanking;
				return;
			}
			else if (addr < 0x2000)
			{ // "Practically any value with 0Ah in the lower 4 bits enables RAM, and any other value disables RAM" 
				if (val & 0xA)
					rambankEnabled = true;
				else rambankEnabled = false;
				return;
			}
			else if (addr >= 0x4000 && addr < 0x6000)
			{ // RAM Bank Number - or - Upper Bits of ROM Bank Number
				word mask = wbits("01100000");

				if (memoryModel == rambanking)
				{ // set ram bank
					swappedrambank = addr & 3; // last 2 bits
				}
				else if (memoryModel == rombanking)
				{ // set high bits of rom bank
					swappedrombank &= ~mask;
					swappedrombank |= (addr & 3) << 5;
				}

				return;
			}
		}
	}

	void MMU::writeb(word addr, byte val)
	{
		if (addr >= 0xC000 && addr < 0xFE00) // internal ram
		{
			addr -= 0xC000;

			// echo values
			ram.internalram8[addr] = val;
			ram.internalramecho8[addr] = val;
			return;
		}
		else if (addr < 0x8000) { // READ-ONLY
			doMBCstuff(addr, val);
			return;
		}

		ram.memory[addr] = val;
	}

	void MMU::writew(word addr, word val)
	{
		writeb(addr, byte(val & 0xFF));
		writeb(addr+1, byte((val & 0xFF00) >> 8));
	}

	byte MMU::readb(word addr) const
	{
		if (addr < 0x8000)
		{
			if (inbios && addr < 0x100)
				return GBbootstrap[addr];
			else if (rom)
			{
				if (!rom->ismbc1() || addr < 0x4000)
					return rom->getaddrvalue(addr);
				else // 0x4000 -> 0x7FFF, do rom banking
					return rom->readBank(swappedrombank, addr - 0x4000);
			}
			else
				return 0;
		} else
			return ram.memory[addr];
	}

	word MMU::readw(word addr) const
	{
		byte low = readb(addr);
		byte high = readb(addr + 1);
		return tow(high, low);
	}
	
	void MMU::assignrom(ROM* rom)
	{
		this->rom = rom;
	}

	void MMU::cleanBIOS()
	{
		inbios = false;
	}
}